
- Purpose: Complete M3→M5 plus Non-Functional with minimal, focused changes; Go 1.21, `gofmt` style, `//go:build ws` guards, and Makefile flows.
- Current: Local sharding, AOI radius, cadence, telemetry, and hysteresis are largely in place. WS transport exists behind `-tags ws`. Bots and persistence are stubs/TODOs.
- Guardrails: Prefer `make` targets for run/test/build; keep PRs ~<300 LOC with tests; WS-only code/tests behind `//go:build ws` and verified by `make test-ws`.

**Phase Plan (2–4 Weeks)**

- M3 (handover polish + AOI continuity): 3–4 days
- M4 (bots + density + wander/separation): 4–6 days
- M5 (persistence + reconnect): 5–7 days
- Non-Functional (obs + security): integrated across phases, last-mile hardening 1–2 days
- CI gates: `make fmt vet test` and `make test-ws` on every PR

**M3 — Local Handover & AOI Continuity**

Tasks by package

- `internal/sim`
  - Intent: Ensure cell handover emits a transport event and AOI remains stable (no dup/loss).
  - Changes:
    - None to core handover math (already in `handovers.go`); maintain current hysteresis logic.
    - Add small helper: `CurrentCell(id string) (spatial.CellKey, bool)` for cheap read of current owned cell (or reuse `GetPlayer`).
  - Acceptance:
    - Handover triggers only after H meters; no thrash at border.
    - AOI includes entities across borders; no duplicates during/after handover.
  - Tests:
    - Unit: border pacing—no premature handover (exists).
    - Unit: AOI cross-border inclusive (exists).
- `internal/transport/ws` (ws build tag)
  - Intent: Emit `handover` event and measure basic metrics around it.
  - Changes (additive protocol):
    - Track `lastCell := ack.Cell` in writer loop; each snapshot tick, compare with current via `eng.GetPlayer`; on change, send `{type:"handover", data:{from:{cx,cz}, to:{cx,cz}}}` before next `state`.
    - Add gauge/counters (expvar-backed) for `ws_connected`, `ws_state_msgs_total`, `ws_state_bytes_total`, `handover_events_total`.
  - Acceptance:
    - Handover event arrives < 250ms from threshold crossing (at next snapshot).
    - No duplicate IDs in `state.entities` around handover.
  - Tests (guarded `//go:build ws`):
    - WS: cross-border move; expect at least one `handover` envelope and subsequent `state` with coherent player cell.
    - WS: AOI entities remain visible across border; no duplicates in a window (e.g., 500ms).
- `cmd/sim`
  - Intent: Expose metrics endpoint.
  - Changes:
    - Register `mux.Handle("/debug/vars", expvar.Handler())` (no third-party deps).
  - Acceptance:
    - `/debug/vars` exposes metrics snapshot; server runs with WS (`make run`).

Protocol & migration

- Additive only: new `handover` envelope; existing clients not broken. No message field renames.
- Bump a simple config `protocol` string in `join_ack.config` if desired (optional).

**M4 — Bots & Density Targets**

Tasks by package

- `internal/sim`
  - Intent: Maintain per‑cell bot density; add wander + simple separation.
  - Changes:
    - `Config` additions: `BotTargetPerCell int`, `BotGlobalCap int` (default 0 disables).
    - Engine state: `botState map[string]*botState`; `bots.go` fleshed out.
    - Tick loop: call `maintainBotDensity()` and `updateBot()` for all bot entities.
    - Spawner: choose random positions within a cell; ensure no spam if global cap reached.
    - Separation: if neighbor within 2m, steer away (simple vector push); clamp `botSpeed`.
  - Acceptance:
    - If a cell population (players+bots) < target, bots spawn to reach target within 10s (±20%).
    - Global cap respected; bots despawn when significantly over target for > 5s.
    - Movement looks plausible (direction retarget 3–7s; max speed ≤ 1.5 m/s).
  - Tests:
    - Unit: deterministic RNG seed; after N steps, observed entity count within target ±20%.
    - Unit: separation—two bots under 2m move apart next ticks.
    - Unit: bot velocity clamp ≤ `botSpeed`.
- `cmd/sim`
  - Intent: Configure bots via flags with safe defaults.
  - Changes:
    - New flags: `-bots_target`, `-bots_cap`; plumb into `sim.Config`.
    - Document in `docs/dev/DEV.md`.
  - Acceptance:
    - `-bots_target=5` yields ~5 entities per cell in ~10s locally.

**M5 — Persistence & Reconnect**

Tasks by package

- `internal/store` (new)
  - Intent: Abstract persistence with a minimal interface for M5.
  - Changes:
    - Define `type PlayerStore interface { Load(ctx, id) (pos spatial.Vec2, ok bool); Save(ctx, id, pos, stat) error }`.
    - `memstore` implementation (in‑memory map) for dev/tests; later swap to Postgres.
  - Acceptance:
    - Simple load/save usable by join and on disconnect; thread‑safe.
  - Tests:
    - Unit: load/save round‑trip; concurrent access safety.
- `internal/join`
  - Intent: Spawn from last known position.
  - Changes:
    - Update `HandleJoin` signature to accept a `PlayerStore` (breaking change within repo).
    - On auth OK: attempt `store.Load`; fall back to `(0,0)`; include pos in `JoinAck`.
  - Acceptance:
    - First login spawns at `(0,0)`; subsequent logins spawn near (≤1m) last saved pos.
  - Tests:
    - Unit: fake store returns saved pos; ack pos matches; error path falls back to `(0,0)`.
- `internal/transport/ws` (ws build tag)
  - Intent: Save on disconnect and enable reconnect.
  - Changes:
    - `Register(...)` accepts a `PlayerStore`; on connection close, fetch latest player snapshot and `store.Save`.
    - Reconnect flow: a new hello with same token leads to normal join (pos restored); no duplicate server entity remains.
      - Implementation detail: On join, `AddOrUpdatePlayer` overwrites if id exists; writer loop tears down with connection close.
  - Acceptance:
    - Drop and reconnect within 2s restores position within 1m; no duplicate player entities or double streaming.
  - Tests:
    - WS: join, move, drop (close socket), rejoin; assert position continuity and entity count == 1 for the id.
- `cmd/sim`
  - Intent: Wire up store; maintain dev simplicity.
  - Changes:
    - Instantiate `memstore` (default). Leave a TODO comment and flag placeholder for Postgres DSN later (no-op now).
  - Acceptance:
    - Works out-of-the-box with in‑memory store; tests GREEN.

Migration

- Breaking compile changes are internal only (new parameter threading). Protocol remains additive.
- Staggered PRs: introduce `internal/store` + join change; then adapt `ws.Register` and call sites.

**Observability**

Metrics (add via `expvar` with `/debug/vars`)

- `sim.tick_time_ms` (float): average tick duration over last N ticks.
- `sim.snapshot_hz` (int): effective snapshot rate computed over last second.
- `sim.snapshot_bytes_total` (int): sum of JSON bytes sent in `state`.
- `sim.entities_in_aoi` (int): last AOI size for current connection; optionally a distribution as min/avg/max counters.
- `sim.handover_latency_ms` (float): time from OwnedCell change detection to event send (approximate at snapshot granularity).
- `sim.ws_connected` (int): current active WS connections.
- Gateway: `gateway.sessions_total`, `gateway.validate_ok_total`, `gateway.validate_fail_total`.

Logging

- Keep brief structured logs for handovers, join, disconnect (ids, cells, latencies).

Tests

- WS (tagged) can sample `/debug/vars` using httptest server to assert metric presence and basic monotonicity (budget friendly).

**Security**

- Auth:
  - Keep token validation via gateway `/validate`; ensure timeouts (e.g., 1s) on HTTP client in `join.HTTPAuth`.
  - Optionally add simple token TTL at gateway (dev only), refreshed on `/login`.
- Input clamps:
  - Already clamp intent to [-1,1] and scale; ignore client `dt`.
  - Add server-side maximum position delta sanity check per tick (optional WARN).
- Heartbeat/timeouts:
  - WS: Add read inactivity timeout (e.g., 30s) by wrapping `wsjson.Read` with `context.WithTimeout`; close if exceeded.
  - Continue server-initiated Ping for telemetry; close on Ping failure.
- Rate limits:
  - Soft-limit input deque size (already drops under backpressure).
- Surface hardening:
  - Ensure `/ws` only with `-tags ws` (already enforced).
  - Avoid panics on malformed JSON; current code ignores unknown/malformed input safely.

**Risk Register**

- Join/store signature change
  - Risk: Widespread mechanical changes. Mitigation: land in small PR (join + memstore + sim wiring), then WS change; keep tests guiding.
- Handover event spam or ordering
  - Risk: Duplicate events near borders. Mitigation: edge-detect with lastCell; send once per change.
- Bot performance in dense scenes
  - Risk: Per-tick neighbor checks. Mitigation: cap bots per cell; simple separation only when within small radius; use cell-local scans.
- Payload growth from bots
  - Risk: Exceed 30KB/s. Mitigation: maintain budget test; lower snapshot rate or AOI radius for bots if needed; consider sampling bots.
- Flaky time-based tests
  - Risk: CI variance. Mitigation: generous tolerances (±20ms cadence), deterministic RNG, retry windows.

**Execution Timeline**

Week 1 (M3 + Observability/Security hooks)

- Day 1–2: WS handover event + tests (`internal/transport/ws`, `cmd/sim` metrics route). Gate: `make test-ws` GREEN.
- Day 3: AOI duplication test around handover; add read timeout + small HTTP client timeout. Gate: `make fmt vet test` GREEN.

Week 2 (M4 Bots)

- Day 4–6: Bot density (+config) + wander, separation, clamps; tests in `internal/sim`. Gate: `make test`.
- Day 7: Payload budget check with bots enabled (ws test). Gate: `make test-ws`.

Week 3 (M5 Persistence)

- Day 8–9: `internal/store` + `join.HandleJoin` signature change + unit tests.
- Day 10: Wire store into `cmd/sim`, adapt `ws.Register` to save on disconnect; reconnect flow tests. Gates: `make test` + `make test-ws`.
- Day 11: Docs updates and backlog status bump; final polish.

Parallelizable streams

- Bots (M4) and store scaffolding (M5) can progress in parallel after M3 merges.
- Observability and security tweaks can land alongside respective features.

**Concrete Changes (by file/module)**

- `backend/internal/transport/ws/register_ws.go`:
  - Add handover event emission (track lastCell).
  - Add `expvar` counters/gauges and increment/update on connect/state/handover.
  - Add read inactivity timeout around `wsjson.Read`.
- `backend/cmd/sim/main.go`:
  - Register `"/debug/vars"` via `expvar.Handler()`.
  - New flags: `-bots_target`, `-bots_cap`; plumb into `sim.Config`.
- `backend/internal/sim/*.go`:
  - `engine.go`: call `maintainBotDensity()` and bot updates in `tick`; helper for current cell read if needed.
  - `bots.go`: implement spawn/despawn + wander + separation; track `botState`.
  - `types.go`: extend `Config` with bot settings (defaults 0).
- `backend/internal/store/` (new):
  - `store.go`: interface + memstore impl + tests.
- `backend/internal/join/join.go`:
  - Modify `HandleJoin(ctx, auth, store, eng, hello)` to load last pos before spawn; update tests.
- `backend/internal/join/auth_http.go`:
  - Add HTTP client timeout (~1s).
- Tests:
  - `backend/internal/transport/ws/ws_integration_test.go`: add handover-event test, AOI cross-border no-dup test, reconnect test (M5).
  - `backend/internal/sim/*_test.go`: add bots density/separation tests.
  - `backend/internal/store/store_test.go`: load/save tests.
  - All WS tests guarded with `//go:build ws`.

**Acceptance Criteria Summary**

- M3:
  - Handover after hysteresis; emits `{type:"handover"}`; AOI contiguous; no dups; latency < 250ms. Tests pass under `make test-ws`.
- M4:
  - Bots maintain per-cell density (±20% in 10s); capped globally; wander + separation; clamps respected. `make test` GREEN.
- M5:
  - Save pos on disconnect; reconnect restores within 1m in <2s; no ghost entities; session integrity. `make test` + `make test-ws` GREEN.
- Non-Functional:
  - `/debug/vars` exposes metrics; inputs clamped; read timeout enforced; gateway validate uses timeout. Light tests and manual checks OK.

**Protocol & Schema Migration Strategy**

- Additive envelopes only (handover, telemetry already present). No breaking changes.
- Document envelope in `docs/dev/DEV.md` and update backlog status notes with a short transcript.
- If future fields added (e.g., version), use optional fields inside `join_ack.config`.

**CI & Gates**

- Every PR:
  - `make fmt vet test` and, when touching WS, `make test-ws`.
  - Keep diffs small; include tests and doc updates:
    - `docs[2025-09-12T18:31:18] ERROR: stream error: stream disconnected before completion: Transport error: error decoding response body; retrying 1/5 in 195ms…

[2025-09-12T18:31:28] thinking

**Creating a Planning Document**

I need to focus on producing a planning document without modifying any files since the system is read-only. The goal is to create a comprehensive, high-leverage implementation plan for moving from milestone M3 to M5, including non-functional aspects, particularly for the Go backend. I'll outline elements like transport, handovers, bots, persistence, observability, and security. Each task will have clear intent, changes proposed, and acceptance criteria, all while adhering to Go 1.21 conventions and keeping changes minimal.
**Outlining Security Measures**

I’m focusing on key security notes like authentication and token validation, velocity clamps, timeouts, and heartbeats. I'll create a risk register with mitigations and an execution timeline that includes parallel streams and CI gates. There are existing tests for areas like AOI and handovers, but I need to add tests for specific handover events, bots, persistence, and enforce NF metrics. I want to align with the docs backlog and address the confusion around the repeated story ID US-202 to propose necessary updates.
**Proposing Implementation Tasks**

I’m suggesting tasks for M3, which include finalizing hysteresis, adding a WebSocket 'handover' event emission when OwnedCell changes, and ensuring AOI across borders involves checking neighbor sets to avoid duplicates and flaps. I'll add a test for AOI that already exists, but we need to verify if it's flagged as Not Started due to features not being wired in. For M4, I’ll work on bots and density, integrating functions into the engine and proposing toggles for target density settings.
**Implementing Spawner and Persistence Features**

I’m planning to implement a spawner that ensures cell entities include bots to maintain minimum counts. I'll set deterministic RNG seeds for tests by allowing RNG injection or setting it during engine initialization. The design will also include logic to remove excess entities when density exceeds a threshold and a separation rule to prevent clustering. For persistence in M5, I’ll start with an in-memory map for local development, with plans for Postgres later, while ensuring compliance with AGENTS guidelines. I'll also enhance the join handler to manage player states.
**Implementing WebSocket and Gateway Enhancements**

I’m working on multiple improvements for WebSocket handling and gateway functionality. I want to save players' positions when they disconnect and rejoin, manage connection lifecycle events, and add heartbeat functionality with timeouts. I'll propose changes to ensure we track ping and pong events accurately. For observability, I’ll incorporate basic metrics using expvar, which will help monitor tick times and connections. Additionally, I need to refine how we send handover events and improve bot configurations, all while ensuring security measures like token validation and rate limiting are in place.
**Drafting Plan for Handover Event and Testing**

I’m proposing a series of tasks to implement and test the 'handover' event and related functionalities. First, I’ll track the timestamp when the lastOwnedCell changes and approximate the crossing time for handover detection. The test plan includes unit tests for handover events, engine tests for bot density, and ensuring player position persistence on reconnect. I’ll also ensure no ghost entities remain on disconnection. Additionally, I’ll integrate a timeout for inactive connections and set up observability tests to verify metrics. Finally, I need to address migration considerations for protocols and schemas, focusing on minimal changes while still implementing relevant configurations.
**Preparing Detailed Plan for Handover Implementation**

I’m outlining our project plan using clear headers and bullet points to maintain organization. Each milestone will have defined acceptance criteria and testing requirements. I’ll describe tasks for M3, M4, and M5 phases, while ensuring references to repository files and code.

For non-functional metrics, I’ll include aspects such as logging, security, and input validation, along with a risk register to note potential obstacles. I'll also lay out a strategic timeline emphasizing parallel tasks. Finally, I'll ensure that comments regarding the Gateway's session updates and observability tests are integrated seamlessly into the plan, reflecting our detailed approach.
[2025-09-12T18:33:11] codex
**Outlining Security Measures**

I’m focusing on key security notes like authentication and token validation, velocity clamps, timeouts, and heartbeats. I'll create a risk register with mitigations and an execution timeline that includes parallel streams and CI gates. There are existing tests for areas like AOI and handovers, but I need to add tests for specific handover events, bots, persistence, and enforce NF metrics. I want to align with the docs backlog and address the confusion around the repeated story ID US-202 to propose necessary updates.
[2025-09-12T18:33:11] codex
**Proposing Implementation Tasks**

I’m suggesting tasks for M3, which include finalizing hysteresis, adding a WebSocket 'handover' event emission when OwnedCell changes, and ensuring AOI across borders involves checking neighbor sets to avoid duplicates and flaps. I'll add a test for AOI that already exists, but we need to verify if it's flagged as Not Started due to features not being wired in. For M4, I’ll work on bots and density, integrating functions into the engine and proposing toggles for target density settings.
[2025-09-12T18:33:11] codex
**Implementing Spawner and Persistence Features**

I’m planning to implement a spawner that ensures cell entities include bots to maintain minimum counts. I'll set deterministic RNG seeds for tests by allowing RNG injection or setting it during engine initialization. The design will also include logic to remove excess entities when density exceeds a threshold and a separation rule to prevent clustering. For persistence in M5, I’ll start with an in-memory map for local development, with plans for Postgres later, while ensuring compliance with AGENTS guidelines. I'll also enhance the join handler to manage player states.
[2025-09-12T18:33:11] codex
**Implementing WebSocket and Gateway Enhancements**

I’m working on multiple improvements for WebSocket handling and gateway functionality. I want to save players' positions when they disconnect and rejoin, manage connection lifecycle events, and add heartbeat functionality with timeouts. I'll propose changes to ensure we track ping and pong events accurately. For observability, I’ll incorporate basic metrics using expvar, which will help monitor tick times and connections. Additionally, I need to refine how we send handover events and improve bot configurations, all while ensuring security measures like token validation and rate limiting are in place.
[2025-09-12T18:33:11] codex
**Drafting Plan for Handover Event and Testing**

I’m proposing a series of tasks to implement and test the 'handover' event and related functionalities. First, I’ll track the timestamp when the lastOwnedCell changes and approximate the crossing time for handover detection. The test plan includes unit tests for handover events, engine tests for bot density, and ensuring player position persistence on reconnect. I’ll also ensure no ghost entities remain on disconnection. Additionally, I’ll integrate a timeout for inactive connections and set up observability tests to verify metrics. Finally, I need to address migration considerations for protocols and schemas, focusing on minimal changes while still implementing relevant configurations.
[2025-09-12T18:33:11] codex
**Preparing Detailed Plan for Handover Implementation**

I’m outlining our project plan using clear headers and bullet points to maintain organization. Each milestone will have defined acceptance criteria and testing requirements. I’ll describe tasks for M3, M4, and M5 phases, while ensuring references to repository files and code.

For non-functional metrics, I’ll include aspects such as logging, security, and input validation, along with a risk register to note potential obstacles. I'll also lay out a strategic timeline emphasizing parallel tasks. Finally, I'll ensure that comments regarding the Gateway's session updates and observability tests are integrated seamlessly into the plan, reflecting our detailed approach.
**Objective**

Deliver a concrete, minimal‑change plan to complete M3→M5 and Non‑Functional goals for the Go backend (gateway + sim), WebSocket transport, AOI, handovers, bots, persistence, observability, and security. Aligns with AGENTS.md, Makefile flows, Go 1.21, and existing tests/build tags.

---

**Phase Plan (2–4 Weeks)**

- Week 1: Finish M3 (handover events, AOI across borders), baseline security hardening, WS tests green.
- Week 2: M4 bots (density target + wander + basic separation) behind config flags; metrics foundation.
- Week 3: M5 persistence (in‑mem store + reconnect + on‑close save/remove), WS reconnection tests.
- Week 4: Non‑Functional polish (metrics, payload gauges, heartbeat), docs/progress updates, CI gates.

Parallelizable streams: Observability metrics + WS gauges (Week 1–2) can proceed alongside bots (Week 2). Persistence and reconnect (Week 3) mostly isolated to `join` + WS close hooks.

---

**M3 — Local Sharding & AOI Continuity**

- Handover Event Emission
  - Intent: Notify clients on cell ownership change; keep it additive and optional.
  - Changes:
    - `backend/internal/transport/ws/register_ws.go`: Track `prevCell` per connection in writer loop. When `p.OwnedCell` changes, send `{ "type": "handover", "data": { "from": {cx,cz}, "to": {cx,cz} } }` immediately, then continue normal state cadence.
    - Add config flag in join ack for client feature detection: `join_ack.config.handover_events: true` (additive).
  - Acceptance:
    - Crossing borders triggers a single `handover` message (<250ms).
    - No duplicate or missing entity ownership during the move.
  - Tests (WS; `//go:build ws`):
    - New `handover_ws_test.go`: drive a player from (9.9,0) east across x=10 with hysteresis satisfied; expect one `handover` with correct from/to cells and subsequent `state` consistent with new cell.

- Hysteresis Thrash Guard (verify/expand)
  - Intent: Ensure stable ownership around borders with noise.
  - Changes:
    - None unless failing tests; current `crossedBeyondHysteresis` is correct and covered.
  - Acceptance:
    - Ownership does not thrash when oscillating within ±(H-ε).
  - Tests:
    - Extend `handovers_test.go` with a pacing sequence (+/−1m around border with H=2m); confirm ownership unchanged.

- AOI Continuity Across Borders
  - Intent: Maintain AOI visibility of neighbors across borders during and after handover.
  - Changes:
    - Engine already queries 3×3 via `QueryAOI`; no change expected.
    - WS state payload already includes `entities` from `QueryAOI`; no change expected.
  - Acceptance:
    - Moving across border keeps entity within radius visible; no AOI flapping.
  - Tests:
    - Existing `TestAOI_CoversAcrossBorder_NoFlap` covers engine; add WS‑level test `aoi_ws_test.go` (move across border while a neighbor sits at +0.5m in next cell; assert continuous presence in `state.entities`).

- Protocol Migration (lean)
  - Additive only: new `handover` envelope and `join_ack.config.handover_events=true`. Legacy clients can ignore unknown `type`.

---

**M4 — Bots & Density**

- Bot Density Target (config‑driven)
  - Intent: Maintain minimum population per cell via bots; off by default.
  - Changes:
    - `backend/internal/sim/types.go`: Extend `Config` with `BotTargetPerCell int`, `BotMaxTotal int` (default 0 disables).
    - `backend/cmd/sim/main.go`: Flags `-bot_target`, `-bot_max`; include in `/config`.
    - `backend/internal/sim/bots.go`: Implement `maintainBotDensity`:
      - Every 500ms, for cells with player presence (or any entity), spawn bots up to `BotTargetPerCell` if under target; despawn if over target.
      - Enforce global cap `BotMaxTotal`.
      - `Engine` helpers: `spawnBot(cellKey)`, `despawnBot(id)`, `countBots(cellKey)`, and bot ID allocator (`bot-<short>`).
    - `backend/internal/sim/engine.go`: Call `maintainBotDensity()` each tick (low overhead).
  - Acceptance:
    - With `BotTargetPerCell=5`, a cell reaches 4–6 bots within 10s and stays within ±20% under churn; global cap enforced.
  - Tests:
    - Unit: Deterministic seed; simulate ticks; assert bot counts per cell and global cap.
    - WS integration: Join, wait for density fill; assert bots included in `entities` with `kind=1` (Bot).

- Wander + Separation
  - Intent: Believable local motion; disperse clusters.
  - Changes:
    - `backend/internal/sim/bots.go` `[2025-09-12T18:33:50] ERROR: stream error: stream disconnected before completion: Transport error: error decoding response body; retrying 2/5 in 375ms…

[2025-09-12T18:34:02] thinking

**Creating a detailed plan**

I need to draft a comprehensive, high-leverage plan based on the user's request for planning only, without file modifications. In this read-only environment, I’ll focus on tasks aligned with AGENTS.md, organizing them by milestones and packages. I'll include acceptance criteria, test plans, and a migration strategy for protocol changes. It's essential to mention observability, security notes, a risk register, and execution timelines. I’ll also incorporate specific file paths and details from the existing code to keep it concrete and relevant.
**Proposing M3 tasks**

I need to propose some M3 tasks, like finishing the hysteresis and adding a handover event to the WebSocket. I want to ensure that the Area of Interest (AOI) remains contiguous across borders, specifically for US-302, while leveraging existing tests. I’ll need to implement the 'handover' event emission when ownership changes in the engine loop, detecting changes in OwnedCell. Also, I should consider how to transport this event to the client effectively, aiming for immediate delivery within a 250ms threshold.
**Refining event detection**

I’m considering that with a snapshot frequency of 10Hz, which translates to 100ms, we should be able to detect changes on each tick in the reader/writer loops. The WebSocket writer loop currently uses a ticker for snapshots and telemetry, so I want to add a check for changes in OwnedCell and send a 'handover' event immediately. I can use either a separate 'handoverCh' or add a check on the ticker to ensure we meet the acceptance criteria of under 250ms. I'll also add tests in ws_integration_test.go to verify this functionality.
**Planning M4 for bots and density**

For M4, I'm focusing on bots and maintaining density. There are placeholder functions, and I need to implement `maintainBotDensity` within the engine's tick or outside of it. I'll call this function at a low cadence, maybe every second, since `engine.tick` already handles handovers. For testing, I plan to use a deterministic random number generator by seeding it in the Engine config. I’ll create a bot states map and ensure bots spawn at random positions near the cell center while integrating configuration fields for limits like `BotTargetPerCell`. I'll break this down into small PR tasks to keep changes manageable.
**Drafting the M5 Plan**

For M5, the first step is to propose in-memory persistence to keep changes minimal. I’ll add a storage interface for saving and loading player states and provide an in-memory implementation for development. Later, I can introduce an optional Postgres setup. I need to ensure quick reconnections and propose saving player states on disconnect while implementing a mechanism to load these states on rejoining. I’ll extend the `join.HandleJoin` to accept a `Persister` interface for this. Additionally, I'll focus on observability by integrating `expvar` for metrics and address security by enforcing timeouts and velocity clamps. I should also lay out a risk register and an execution timeline with weekly sprints.
**Structuring the Plan with Requirements**

I’ll include adjustments to 'wsprobe' for optional telemetry and 'handover' events while keeping it straightforward for development. We need to set acceptance criteria for tasks and mention build tags for ws-specific tests. I'll ensure to address observability and security, using Makefile targets without modifying files directly. 

My plan will start with 'Scope & Assumptions' referencing AGENTS.md, then present a 'Phased Plan Overview' detailing milestones M3, M4, and M5. I'll organize tasks in clear sections with defined acceptance conditions, metrics tracking, and list any risks or feature flags needed.
**Finalizing Configuration Changes**

In the Go code, I'm proposing new fields in `sim.Config`, including optional ones like `BotTargetPerCell`, `BotMaxTotal`, and flags for persistence and timeouts. Specifically, I might add `PersistenceEnabled` as a boolean and strings for `StoreDSN`, along with integer fields for `ReadTimeoutSec` and `HeartbeatTimeoutSec`.

For command-line options, I will recommend flags like `bots`, `bots_target`, `bots_cap`, `persist`, `dsn`, `idle`, and `readtimeout`. It's important to maintain our WS tests with appropriate build tags. With this finalized, I can confidently prepare the plan document, highlighting that the US-202 snapshot test is complete while also suggesting optional improvements for `wsprobe`.
[2025-09-12T18:35:34] codex
**Proposing M3 tasks**

I need to propose some M3 tasks, like finishing the hysteresis and adding a handover event to the WebSocket. I want to ensure that the Area of Interest (AOI) remains contiguous across borders, specifically for US-302, while leveraging existing tests. I’ll need to implement the 'handover' event emission when ownership changes in the engine loop, detecting changes in OwnedCell. Also, I should consider how to transport this event to the client effectively, aiming for immediate delivery within a 250ms threshold.
[2025-09-12T18:35:34] codex
**Refining event detection**

I’m considering that with a snapshot frequency of 10Hz, which translates to 100ms, we should be able to detect changes on each tick in the reader/writer loops. The WebSocket writer loop currently uses a ticker for snapshots and telemetry, so I want to add a check for changes in OwnedCell and send a 'handover' event immediately. I can use either a separate 'handoverCh' or add a check on the ticker to ensure we meet the acceptance criteria of under 250ms. I'll also add tests in ws_integration_test.go to verify this functionality.
[2025-09-12T18:35:34] codex
**Planning M4 for bots and density**

For M4, I'm focusing on bots and maintaining density. There are placeholder functions, and I need to implement `maintainBotDensity` within the engine's tick or outside of it. I'll call this function at a low cadence, maybe every second, since `engine.tick` already handles handovers. For testing, I plan to use a deterministic random number generator by seeding it in the Engine config. I’ll create a bot states map and ensure bots spawn at random positions near the cell center while integrating configuration fields for limits like `BotTargetPerCell`. I'll break this down into small PR tasks to keep changes manageable.
[2025-09-12T18:35:34] codex
**Drafting the M5 Plan**

For M5, the first step is to propose in-memory persistence to keep changes minimal. I’ll add a storage interface for saving and loading player states and provide an in-memory implementation for development. Later, I can introduce an optional Postgres setup. I need to ensure quick reconnections and propose saving player states on disconnect while implementing a mechanism to load these states on rejoining. I’ll extend the `join.HandleJoin` to accept a `Persister` interface for this. Additionally, I'll focus on observability by integrating `expvar` for metrics and address security by enforcing timeouts and velocity clamps. I should also lay out a risk register and an execution timeline with weekly sprints.
[2025-09-12T18:35:34] codex
**Structuring the Plan with Requirements**

I’ll include adjustments to 'wsprobe' for optional telemetry and 'handover' events while keeping it straightforward for development. We need to set acceptance criteria for tasks and mention build tags for ws-specific tests. I'll ensure to address observability and security, using Makefile targets without modifying files directly. 

My plan will start with 'Scope & Assumptions' referencing AGENTS.md, then present a 'Phased Plan Overview' detailing milestones M3, M4, and M5. I'll organize tasks in clear sections with defined acceptance conditions, metrics tracking, and list any risks or feature flags needed.
[2025-09-12T18:35:34] codex
**Finalizing Configuration Changes**

In the Go code, I'm proposing new fields in `sim.Config`, including optional ones like `BotTargetPerCell`, `BotMaxTotal`, and flags for persistence and timeouts. Specifically, I might add `PersistenceEnabled` as a boolean and strings for `StoreDSN`, along with integer fields for `ReadTimeoutSec` and `HeartbeatTimeoutSec`.

For command-line options, I will recommend flags like `bots`, `bots_target`, `bots_cap`, `persist`, `dsn`, `idle`, and `readtimeout`. It's important to maintain our WS tests with appropriate build tags. With this finalized, I can confidently prepare the plan document, highlighting that the US-202 snapshot test is complete while also suggesting optional improvements for `wsprobe`.
**Scope & Principles**

- Aligns with AGENTS.md and Makefile flows; Go 1.21, ws-only code/tests behind `//go:build ws`; prefer `make fmt vet test` and `make test-ws`.
- Minimal, focused changes; small PRs with tests and docs updates in `docs/process/*` and `docs/dev/DEV.md`.

**Horizon & Outcomes (2–4 Weeks)**

- M3: Finish hysteresis handover; contiguous AOI across borders; emit `handover` event over WS.
- M4: Bot density targets per cell; simple wander + separation; caps.
- M5: Persistence: save pos + simple stat on disconnect; reconnect resumes state.
- Non‑Functional: Observability (expvar) and Security (timeouts, clamps, heartbeat).

---

**Milestone M3 — Handover + AOI**

- Intent: Complete local sharding handover with hysteresis, ensure AOI continuity, and surface handover to clients.
- Changes:
  - `backend/internal/transport/ws/register_ws.go` (ws):
    - Add handover event emission: track `lastCell`; on change, send `{type:"handover", data:{from:{cx,cz}, to:{cx,cz}}}` immediately or at next snapshot (≤100ms).
    - Add reader idle timeout (e.g., 15s) via per‑read context deadline to drop silent clients.
    - Metrics (expvar): increment `sim_ws_handover_total`, record `sim_ws_handover_latency_ms` (event sent time − cell change detect time; detect at snapshot observation).
    - Metrics (expvar): `sim_ws_connected` gauge; `sim_snapshot_bytes_total` (sum of JSON len).
  - `backend/internal/sim/handovers.go`:
    - Keep hysteresis logic; no API change. Add micro‑helper to fetch player’s `OwnedCell` for ws loop (already via `GetPlayer`).
  - Tests:
    - Unit: `internal/sim/handovers_test.go` table expanded: diagonal crossings, negative coords, border epsilon.
    - WS integration (ws): new test `handover_event_test.go` in `internal/transport/ws`:
      - Join, set velocity to cross east border; assert receive a `handover` with correct cells within 250ms of crossing (tolerate snapshot cadence).
    - AOI continuity (engine): extend `aoi_test.go` to move across border and ensure neighbor remains visible pre/post handover (no duplicates).
  - Acceptance:
    - Handover occurs only after ≥H meters into target cell; `handover` event delivered within ≤250ms; AOI results stable across border; `make test` + `make test-ws` GREEN.

---

**Milestone M4 — Bots & Density**

- Intent: Maintain per‑cell population targets with simple bot behavior; enforce caps.
- Changes:
  - `backend/internal/sim/types.go`:
    - Extend `Config` with `BotTargetPerCell int`, `BotMaxTotal int`.
  - `backend/internal/sim/bots.go`:
    - Implement `maintainBotDensity()`:
      - Every ~1s, for each populated cell with players, ensure `countBots(cell) ~ BotTargetPerCell` within ±20%; spawn/despawn bots as needed; respect `BotMaxTotal`.
      - Spawn position: random within cell bounds with margin; ID `bot-<short>`.
      - Keep `botState` map; reuse existing `updateBot` to set velocity; add basic separation when <2m (steer away, clamp speed).
  - `backend/internal/sim/engine.go`:
    - Call `maintainBotDensity()` on a 1Hz ticker (cheap) and call `updateBot(...)` per tick for existing bots.
  - Tests:
    - Unit: deterministic RNG via `rand.Seed(1)` in test; simulate ticks; assert bot counts per cell in [target-20%, target+20%]; assert global cap.
    - WS integration (ws): join, wait ≤10s; assert `entities` includes bots (`kind=1`) and stays within bounds across a few snapshots.
  - Acceptance:
    - With `BotTargetPerCell=5`, cell converges to 4–6 bots ≤10s; stays within ±20% under churn; cap enforced; GREEN tests.

---

**Milestone M5 — Persistence & Reconnect**

- Intent: Persist last position + simple stat; restore on join; save on disconnect.
- Changes:
  - `backend/internal/join`:
    - Add optional persistence hook via new interface `LoaderSaver` (new file `persist.go`):
      - `Load(ctx, playerID) (pos spatial.Vec2, ok bool)`, `Save(ctx, playerID, pos spatial.Vec2, stat int) error`.
    - Extend `HandleJoin` to accept an optional `LoaderSaver` (nil-safe) and, when present, load last pos before `eng.AddOrUpdatePlayer`.
    - Update unit tests to cover default (no loader) and with loader.
  - `backend/cmd/sim/main.go`:
    - Flags: `-persist` (bool, default false), `-dsn` (string, optional).
    - Wire a `LoaderSaver` implementation:
      - Default: in‑memory map (CI friendly).
      - Optional (later PR): postgres stub behind build tag or interface (not required for CI).
    - Add expvar import to expose `/debug/vars` implicitly; add simulation metrics registries.
  - `backend/internal/transport/ws/register_ws.go`:
    - On connection close (defer), if persistence enabled, `Save` last pos and stat.
    - Heartbeat: if idle timeout triggers, still persist.
  - Tests:
    - Unit: `join` with fake `LoaderSaver` returns loaded pos; `Save` called on “close”.
    - WS integration (ws): join, move, close (client side), rejoin; assert start pos within ≤1m of saved pos.
  - Acceptance:
    - Save on disconnect; reconnect restores within 1m in <2s; no ghost entities; `make test` + `make test-ws` GREEN.

---

**Non‑Functional — Observability**

- Intent: Minimal metrics via stdlib `expvar` exposed at `/debug/vars` on sim HTTP server.
- Metrics to add:
  - `sim_tick_ms` (last tick duration), `sim_snapshot_bytes_total`, `sim_entities_in_aoi` (last count), `sim_ws_connected` (gauge), `sim_ws_handover_total`, `sim_ws_handover_latency_ms` (last).
- Changes:
  - `backend/cmd/sim/main.go`: import `_ "expvar"`; initialize expvar.Int/Float vars; plumb simple setters from engine and ws.
  - `backend/internal/transport/ws/register_ws.go`: bump counters/gauge; accumulate snapshot byte totals.
  - `backend/internal/sim/engine.go`: measure tick duration; publish to expvar.
- Tests:
  - Light integration (optional): probe vars in process using http test server; assert presence and sane ranges.

---

**Non‑Functional — Security**

- Token validation:
  - `backend/internal/join/auth_http.go`: set `http.Client{Timeout: 1 * time.Second}`; per‑request context timeout.
- Transport:
  - Input clamps: keep `clamp()` and server‑side speed constant; ignore client `dt` for velocity.
  - Idle timeout: `wsjson.Read` with context deadline (e.g., 15s) in reader goroutine; disconnect if idle.
  - Sequence handling: keep ack monotonic; ignore out‑of‑order lower seq.
  - Add basic read payload limit via size guard on `json.RawMessage` length before unmarshal (drop oversized).
- Engine/gameplay:
  - Velocity cap enforced server‑side; reject impossible intent (>1).
- Tests:
  - Auth failure path (already covered); velocity clamp (send 999 intent; speed stays at cap); idle timeout disconnect (reader exits after deadline).

---

**Protocol & Schema Migration**

- Strategy: additive only; maintain envelope `{type, data, error?}`.
- New messages: `handover` event (M3).
- New fields: metrics and config additions in `join_ack.config` may include `bots_enabled`, `target_per_cell`, `persistence` flags (optional).
- Docs: update `docs/dev/DEV.md` (WS envelopes), `docs/process/BACKLOG.md` and `PROGRESS.md` with status and test notes.
- Versioning: if necessary, add optional `version` in `join_ack.config`; not required for current scope.

---

**Risks & Mitigations**

- AOI boundary flapping: Use `eps` tolerance (already in `QueryAOI`); test diagonal and epsilon cases.
- Time‑based test flakiness: Use broad tolerances and deterministic seeds; rely on snapshot cadence tolerances ±20ms.
- Bot thrash: Tick separation logic and 1Hz density loop; hysteresis on spawn/despawn (e.g., ±20% band).
- Persistence coupling: Keep behind interface; default in‑mem; DB optional later to avoid CI deps.
- WS backpressure: Non‑blocking writes with 2s deadline; drop on timeout; measure payload bytes to watch budget.
- Large diffs risk: Slice into focused PRs per story (≤300 LOC) with tests.

---

**Execution Timeline & Parallelization**

- Week 1 (M3 focus):
  - WS handover event + idle timeout + metrics (ws) [ws-only].
  - AOI continuity test expansion (engine).
  - CI: `make fmt vet test` + `make test-ws` GREEN.
- Week 2 (M4 focus):
  - Config fields + `maintainBotDensity` + wander/separation.
 [2025-09-12T18:36:22] ERROR: stream error: stream disconnected before completion: Transport error: error decoding response body; retrying 3/5 in 875ms…

[2025-09-12T18:36:39] thinking

**Considering options for cell management**

I’m weighing two options for handling cell management in a connection. Option A suggests keeping a lastCell per connection to compare changes in player cells and send an event when it updates. Option B involves a more complex approach with an engine emitting a handover channel. 

I need to ensure continuity when players move across borders, maintaining their proximity to neighbors. Plus, I’ll address some "TODO" comments related to maintaining bot density. Keeping a deterministic random seed might be prudent too!
**Updating bot configuration and states**

I’m working on tests to ensure deterministic behavior by setting `rand.Seed`. I need to add configuration fields for bots like BotTargetPerCell, BotMaxTotal, and BotEnabled while keeping the code under 300 lines. My plan is to include two config fields and a maintain function operating at 1Hz.

I’ll need to decide where to store the bot state; since Entities exist within cell and players maps, I can use a separate map for bot states in the Engine. Adding a simple `map[string]*botState` should work, even if it slightly exceeds the changes I initially anticipated.
**Implementing bot density maintenance**

I need to add a `maintainBotDensity` function that iterates through cells, counts current bots, and spawns new ones if the count is below the target and the global cap isn’t exceeded. Each new bot will have a random position and a `botState` initialized with the current time.

Next, I'll update the tick function to manage these bots. Currently, the tick only integrates player velocities, so I’ll need to iterate over all entities in each cell. I should ensure that bot positions are updated based on their velocities and add general integration for bot entities to ensure proper movement!
**Combining player and bot integration**

I’m thinking about how to integrate both players and bots effectively. I can loop through cells to update the positions of non-player entities while keeping the existing player integration. This may require some extra code, but it's manageable.

For testing bot density, I’ll configure `BotTargetPerCell` to be small and `BotMaxTotal` to be large, then step through time to ensure the count of bots in each cell is close to the target. I’ll also make sure the maintain function runs correctly during the tests!
**Planning a systems update**

I’m considering the integration of maintaining bot density and ensuring it’s deterministic. To do this, I’ll implement a 'lastDensityCheck' field and schedule the maintain function after each tick. We want to control bot spawning to avoid thrashing.

For persistence, I plan to add an in-memory store interface, integrating it into the `HandleJoin` function without disturbing the existing signature too much.

Moving on to observability, utilizing expvar for metrics sounds good, including tracking connection pings and maintaining a grasp of latency. There are numerous tasks to accomplish in the coming weeks, so I’ll structure our workload carefully!
**Crafting the structured plan**

I need to create a structured plan document that follows the "Final answer structure and style guidelines." This means keeping things concise, ideally within 10 lines, while including relevant details like acceptance criteria and testing for each task.

I will organize the plan by milestones and packages, detailing file changes needed. Additionally, I’ll outline a risk register, migration strategy, and observability metrics. Key components will include build tags for tests, ensuring minimal changes, and specific sections addressing security, timeline, and CI gates. I’ll integrate everything into a clear, comprehensive format for easy implementation!
[2025-09-12T18:37:47] codex
**Updating bot configuration and states**

I’m working on tests to ensure deterministic behavior by setting `rand.Seed`. I need to add configuration fields for bots like BotTargetPerCell, BotMaxTotal, and BotEnabled while keeping the code under 300 lines. My plan is to include two config fields and a maintain function operating at 1Hz.

I’ll need to decide where to store the bot state; since Entities exist within cell and players maps, I can use a separate map for bot states in the Engine. Adding a simple `map[string]*botState` should work, even if it slightly exceeds the changes I initially anticipated.
[2025-09-12T18:37:47] codex
**Implementing bot density maintenance**

I need to add a `maintainBotDensity` function that iterates through cells, counts current bots, and spawns new ones if the count is below the target and the global cap isn’t exceeded. Each new bot will have a random position and a `botState` initialized with the current time.

Next, I'll update the tick function to manage these bots. Currently, the tick only integrates player velocities, so I’ll need to iterate over all entities in each cell. I should ensure that bot positions are updated based on their velocities and add general integration for bot entities to ensure proper movement!
[2025-09-12T18:37:47] codex
**Combining player and bot integration**

I’m thinking about how to integrate both players and bots effectively. I can loop through cells to update the positions of non-player entities while keeping the existing player integration. This may require some extra code, but it's manageable.

For testing bot density, I’ll configure `BotTargetPerCell` to be small and `BotMaxTotal` to be large, then step through time to ensure the count of bots in each cell is close to the target. I’ll also make sure the maintain function runs correctly during the tests!
[2025-09-12T18:37:47] codex
**Planning a systems update**

I’m considering the integration of maintaining bot density and ensuring it’s deterministic. To do this, I’ll implement a 'lastDensityCheck' field and schedule the maintain function after each tick. We want to control bot spawning to avoid thrashing.

For persistence, I plan to add an in-memory store interface, integrating it into the `HandleJoin` function without disturbing the existing signature too much.

Moving on to observability, utilizing expvar for metrics sounds good, including tracking connection pings and maintaining a grasp of latency. There are numerous tasks to accomplish in the coming weeks, so I’ll structure our workload carefully!
[2025-09-12T18:37:47] codex
**Crafting the structured plan**

I need to create a structured plan document that follows the "Final answer structure and style guidelines." This means keeping things concise, ideally within 10 lines, while including relevant details like acceptance criteria and testing for each task.

I will organize the plan by milestones and packages, detailing file changes needed. Additionally, I’ll outline a risk register, migration strategy, and observability metrics. Key components will include build tags for tests, ensuring minimal changes, and specific sections addressing security, timeline, and CI gates. I’ll integrate everything into a clear, comprehensive format for easy implementation!
**Scope**

- Focus: Go backend (`cmd/gateway`, `cmd/sim`, `internal/{sim,spatial,join,transport/ws}`).
- Goals: Complete M3 (handover + AOI continuity), M4 (bots/density), M5 (persistence + reconnect), and Non‑Functional (observability + security).
- Guardrails: Small, focused PRs (<~300 LOC), Go 1.21, `gofmt`, `make` targets, WS code/tests under `//go:build ws`.

**Milestone Plan (M3→M5 + Non‑Functional)**

- M3 — Handover + AOI Continuity
  - Intent: Finalize hysteresis handover and surface a transport event; ensure AOI continuity across borders.
  - Changes:
    - `internal/transport/ws/register_ws.go`:
      - Add “handover” envelope when player’s `OwnedCell` changes (compare against last seen cell per-connection).
      - Track last cell in writer loop; send `{"type":"handover","data":{"from":{cx,cz},"to":{cx,cz}}}` before first “state” after change.
      - WS counters: increment on accept, decrement on close (for metrics); measure bytes for each “state” write.
      - Idle timeout/heartbeat: track last input time; disconnect after configurable idle (default 60s).
    - `internal/sim/handovers.go`:
      - No algorithm change (already implements hysteresis); add a tiny helper (unexported) to return boolean if a handover occurred this tick for a given player ID (optional). Minimal path uses WS-side detection only.
    - Tests:
      - `internal/transport/ws/ws_integration_test.go` (ws): new test “handover event”:
        - Join, set velocity to cross east border beyond hysteresis; assert a `handover` envelope observed within 250ms.
        - Assert next “state” shows `player.pos` monotonic and no duplicate entities.
      - `internal/sim/aoi_test.go`: already has border continuity test; add one more case for north/south border.
    - Acceptance:
      - Handover event emitted with correct `from`→`to` values; arrives <250ms from crossing threshold.
      - AOI continuity holds across borders for 3×3 neighborhood; no duplicates.
  - Make targets: `make test` + `make test-ws` GREEN.

- M4 — Bots & Density
  - Intent: Maintain target density per cell with simple wander and separation; keep diffs small and deterministic in tests.
  - Changes:
    - `internal/sim/types.go`:
      - Extend `Config`: `BotEnabled bool`, `BotTargetPerCell int`, `BotMaxTotal int`.
    - `internal/sim/engine.go`:
      - Add bot tick/update: integrate non-player `Entity` positions (bots) each tick alongside players.
      - Call `maintainBotDensity()` every tick (fast path) and keep actual spawn/despawn throttled at ~1 Hz inside that function to prevent thrash.
    - `internal/sim/bots.go`:
      - Implement `maintainBotDensity()`:
        - For each cell, count bots; if `< target` and under global cap, spawn up to N (small batch, e.g., 1–2 per tick) at random in-bounds positions; if `> target*1.2`, despawn down to hysteresis band (±20%).
      - Implement `updateBot()` (exists) + add minimal separation: if another entity within <2m, bias direction away slightly.
      - Add `spawnBot(cellKey)`/`despawnBot(id)` helpers; keep IDs as `bot-<short>`.
    - `cmd/sim/main.go`:
      - Flags: `-bots` (bool), `-bots_target` (int, default 0), `-bots_cap` (int).
      - Set these into `sim.Config`.
    - Tests:
      - `internal/sim/bots_test.go`: deterministic `rand.Seed`; create 1 cell; set target=5, cap large:
        - Step 10s worth of ticks; assert 4–6 bots present and stable within band; assert cap enforced when target is high.
      - `internal/transport/ws/ws_integration_test.go` (ws): join, wait up to ~2s; assert `entities` include bots (`kind=1`) and remain within AOI radius bounds.
    - Acceptance:
      - With `BotTargetPerCell=5`, a populated cell reaches 4–6 bots within ~10s and remains within ±20%.
      - Global cap respected; bots wander with speed clamp; no clustering at <2m on average over 10s.

- M5 — Persistence + Reconnect
  - Intent: Save player position on disconnect; load last known position on join; support reconnect in <2s without ghosts.
  - Changes (minimal, pluggable, no external DB dependency by default):
    - `internal/store` (new small package):
      - Interface `PlayerStore { GetPos(ctx, playerID) (spatial.Vec2, bool); SavePos(ctx, playerID, pos spatial.Vec2) error }`
      - `memstore.go` in-memory impl for CI/tests.
    - `internal/join/join.go`:
      - Replace the `TODO (M5)` with: if `store != nil` and hit, use saved position; else default.
      - Approach: add an optional `join.SpawnPolicy` or pass `store` into `HandleJoin` via small wrapper; to keep signature stable, add `join.HandleJoinWithStore(ctx, auth, eng, store, hello)` and keep existing `HandleJoin` delegating with `nil`.
    - `internal/transport/ws/register_ws.go`:
      - On handler exit (defer), fetch player’s latest position via `eng.GetPlayer()` and `store.SavePos()`; ensure not called twice; protect with context timeout 500ms.
    - `cmd/sim/main.go`:
